# Research: MCP UX Improvements (008)

**Date**: 2026-02-19  
**Branch**: `008-mcp-ux-improvements`

All NEEDS CLARIFICATION items from Technical Context resolved below.

---

## R-001: TOML Schema for `relationships.toml`

**Decision**: Use TOML array-of-tables (`[[relationships]]`) with a `RelationshipsFile` wrapper struct.

**Rationale**: More explicit and readable than a top-level map; easier to append/remove entries; idiomatic with go-toml v2; each system gets one file at `src/<system-id>/relationships.toml` alongside the existing `system.md`.

**Concrete file format**:

```toml
# C4 Model Relationships
# Generated by loko

[[relationships]]
id = "agwe-api-lambda-to-sqs-queue"
source = "agwe/api-lambda"
target = "agwe/sqs-queue"
label = "Enqueue email job"
type = "async"
technology = "AWS SDK SQS"
direction = "forward"

[[relationships]]
id = "agwe-worker-to-ses"
source = "agwe/worker-lambda"
target = "agwe/ses"
label = "Send email via SES"
type = "sync"
technology = "AWS SDK SES"
direction = "forward"
```

**Go struct** (`internal/core/entities/relationship.go`):

```go
type Relationship struct {
    ID         string `toml:"id"                    json:"id"`
    Source     string `toml:"source"                json:"source"`
    Target     string `toml:"target"                json:"target"`
    Label      string `toml:"label"                 json:"label"`
    Type       string `toml:"type,omitempty"        json:"type,omitempty"`
    Technology string `toml:"technology,omitempty"  json:"technology,omitempty"`
    Direction  string `toml:"direction,omitempty"   json:"direction,omitempty"`
}

type RelationshipsFile struct {
    Relationships []Relationship `toml:"relationships" json:"relationships"`
}
```

**ID generation**: Deterministic hash — `fmt.Sprintf("%x", sha256.Sum256([]byte(source+"->"+target+":"+label)))[:8]` using stdlib `crypto/sha256`. No external deps. Produces stable IDs (same relationship = same ID) enabling idempotent `create_relationship`.

**Atomic write pattern**: Write to `<path>.tmp`, then `os.Rename(tmpPath, path)`. Clean up temp file on error. Standard Go pattern; compatible with the existing `os.WriteFile` usage in `filesystem/project_repo.go`.

**Alternatives considered**:
- Top-level map keyed by ID: harder to iterate in TOML, less readable.
- UUID IDs: requires external `google/uuid` dep, violates YAGNI + core/ zero-dep rule.
- Sequential integers: not deterministic; creates merge conflicts in git.

---

## R-002: D2 Edge Generation from Relationships

**Decision**: Container-to-container relationships → appended to `system.d2`. Component-to-component (same container) → appended to the container's `container.d2`. Regenerate entire edges section from `relationships.toml` on every write (not line-by-line append).

**Rationale**: Regeneration is simpler and correct — no D2 parser needed to locate/remove old edges. Idempotent by construction: write all edges from `relationships.toml` each time. Consistent with the existing pattern in `UpdateSystemD2File` / `UpdateContainerD2File`.

**Which diagram file per relationship level**:

| Source level | Target level | Write to |
|---|---|---|
| Container | Container (same system) | `src/<system>/system.d2` |
| Component | Component (same container) | `src/<system>/<container>/container.d2` |
| Component | Component (cross-container) | `src/<system>/system.d2` (parent boundary) |

**D2 edge syntax**:

```go
func RelationshipToD2Edge(rel entities.Relationship) string {
    arrow := "->"
    if rel.Direction == "bidirectional" {
        arrow = "<->"
    }
    // Extract short IDs (last path segment) for D2 node references
    src := lastSegment(rel.Source)
    tgt := lastSegment(rel.Target)

    switch rel.Type {
    case "async":
        return fmt.Sprintf("%s %s %s: { label: %q; style.animated: true }\n", src, arrow, tgt, rel.Label)
    case "event":
        return fmt.Sprintf("%s %s %s: { label: %q; style.stroke-dash: 5 }\n", src, arrow, tgt, rel.Label)
    default: // "sync" or empty
        return fmt.Sprintf("%s %s %s: %q\n", src, arrow, tgt, rel.Label)
    }
}
```

**Idempotency**: The `RelationshipsFile` ID field (deterministic hash) prevents duplicates at the storage layer. On `create_relationship`, check if an entry with the same ID already exists in `relationships.toml` before appending.

**Alternatives considered**:
- Line-by-line append/remove: requires parsing D2 to find and remove old edges; fragile with manual edits.
- Separate `_relationships.d2` include file: cleaner but D2 include syntax adds complexity; defer to future.

---

## R-003: Slug Suggestion in Error Messages

**Decision**: Add `suggestSlugID(input string, graph *entities.ArchitectureGraph) string` and `notFoundError(entityType, input, suggestion string) error` to `internal/mcp/tools/helpers.go`.

**Implementation**:

```go
// suggestSlugID returns the likely correct slug for a given display name.
// Returns empty string if graph is nil or no match found.
func suggestSlugID(input string, graph *entities.ArchitectureGraph) string {
    if graph == nil {
        return ""
    }
    normalized := entities.NormalizeName(input)
    if graph.GetNode(normalized) != nil {
        return normalized
    }
    if qualifiedID, ok := graph.ResolveID(normalized); ok {
        return qualifiedID
    }
    return ""
}

// notFoundError formats a "not found" error with an optional "did you mean?" hint.
func notFoundError(entityType, input, suggestion string) error {
    base := fmt.Sprintf("%s %q not found", entityType, input)
    if suggestion != "" {
        return fmt.Errorf("%s — did you mean %q?", base, suggestion)
    }
    return fmt.Errorf("%s — run 'query_architecture' to see available element IDs", base)
}
```

**Fallback**: When graph is nil (tool called before graph is built) or suggestion is empty, direct user to `query_architecture`.

**Placement**: `internal/mcp/tools/helpers.go` — correct per architecture rules (mcp/ may import core/).

**Tools needing the slug hint** (existing tools to update):
- `update_component.go` — component lookup
- `update_container.go` — container lookup
- `update_system.go` — system lookup
- `graph_tools.go` — `query_dependencies`, `query_related_components`
- All three new relationship tools (create/list/delete)

**Alternatives considered**:
- Fuzzy matching (levenshtein): external dep, overkill for single slug suggestion.
- Return slug suggestion in every error unconditionally: too noisy when graph context unavailable.

---

## R-004: Container Diagram Auto-Initialization

**Decision**: Inject `DiagramGenerator` into `CreateContainerTool` via constructor parameter. Pass it to `ScaffoldEntity` via existing `WithDiagramGenerator` option. Wire in `registry.go`.

**Change to CreateContainerTool**:

```go
type CreateContainerTool struct {
    repo             usecases.ProjectRepository
    diagramGenerator usecases.DiagramGenerator  // NEW
}

func NewCreateContainerTool(repo usecases.ProjectRepository, dg usecases.DiagramGenerator) *CreateContainerTool {
    return &CreateContainerTool{repo: repo, diagramGenerator: dg}
}

// In Call():
scaffoldUC := usecases.NewScaffoldEntity(t.repo, usecases.WithDiagramGenerator(t.diagramGenerator))
```

**Scaffold output**: `scaffold_entity.go` lines 221–236 call `GenerateContainerDiagram(system)` which generates a system-scoped container diagram (shows all containers in the system). This is a reasonable scaffold — it shows the new container's node immediately. The `diagramMsg` branch at line 106 already handles the path when non-empty, so the "Use 'update_diagram' tool" fallback message is eliminated as a side effect.

**Registry wiring**: `tools/registry.go` (or equivalent construction site) needs to pass `d2.NewGenerator()` (the concrete `DiagramGenerator`) to `NewCreateContainerTool`. The `d2` adapter already exists and implements `DiagramGenerator`.

**Alternatives considered**:
- Generate a minimal hardcoded D2 stub (just container name node): simpler but diverges from the system-scoped diagram pattern already used for `create_system`. Rejected for inconsistency.

---

## R-005: Batch `create_components` Tool

**Decision**: New `CreateComponentsTool` in `internal/mcp/tools/create_components.go`. Accepts top-level `system_name`, `container_name`, and `components` array. Loops sequentially over component definitions, calls `ScaffoldEntity` per item, collects per-item results. Handler stays under 100 lines by delegating all per-item logic to the existing use case.

**MCP Input Schema** (`components` array):

```json
{
  "type": "object",
  "required": ["project_root", "system_name", "container_name", "components"],
  "properties": {
    "project_root":    { "type": "string" },
    "system_name":     { "type": "string" },
    "container_name":  { "type": "string" },
    "components": {
      "type": "array",
      "minItems": 1,
      "items": {
        "type": "object",
        "required": ["name"],
        "properties": {
          "name":          { "type": "string" },
          "description":   { "type": "string" },
          "technology":    { "type": "string" },
          "tags":          { "type": "array", "items": { "type": "string" } }
        }
      }
    }
  }
}
```

**Response structure** (mixed success/error per item):

```json
{
  "created": 4,
  "failed": 1,
  "results": [
    { "id": "request-validator", "name": "Request Validator", "status": "created" },
    { "name": "Rate Limiter", "status": "error", "error": "component already exists" }
  ]
}
```

**Handler skeleton** (stays under 100 lines):

```go
func (t *CreateComponentsTool) Call(ctx context.Context, args map[string]any) (any, error) {
    projectRoot, systemName, containerName := parseCommonArgs(args)
    componentDefs, _ := args["components"].([]any)
    if len(componentDefs) == 0 {
        return nil, fmt.Errorf("components array must have at least one item")
    }
    results := make([]map[string]any, 0, len(componentDefs))
    created, failed := 0, 0
    for _, def := range componentDefs {
        item, _ := def.(map[string]any)
        name, _ := item["name"].(string)
        // ... parse description, technology, tags
        uc := usecases.NewScaffoldEntity(t.repo)
        res, err := uc.Execute(ctx, &usecases.ScaffoldEntityRequest{...})
        if err != nil {
            results = append(results, map[string]any{"name": name, "status": "error", "error": err.Error()})
            failed++
        } else {
            results = append(results, map[string]any{"id": res.EntityID, "name": name, "status": "created"})
            created++
        }
    }
    return map[string]any{"created": created, "failed": failed, "results": results}, nil
}
```

**Alternatives considered**:
- `create_container_with_components` convenience tool: solves a narrower problem; doesn't help when container already exists. Rejected.
- Parallel execution: concurrency in `ScaffoldEntity` would require mutex on filesystem writes; sequential is simpler and safe.

---

## R-006: Validate Isolation Suppression Implementation

**Decision**: In `ValidateArchitecture.checkIsolatedComponents()`, count total edges in the graph before running isolation checks. If `graph.EdgeCount() == 0`, skip the check entirely (return without emitting any findings).

**Implementation** (`validate_architecture.go`):

```go
func (uc *ValidateArchitecture) checkIsolatedComponents(
    graph *entities.ArchitectureGraph,
    report *ArchitectureReport,
) {
    // FR-012: suppress entirely when no relationships exist project-wide
    if graph.EdgeCount() == 0 {
        return
    }
    // ... existing isolation check logic unchanged ...
}
```

**Why `graph.EdgeCount()`**: The graph is built from both `relationships.toml` (new) and D2 edges (existing). Zero edges means zero relationships anywhere in the project, which is the project-wide zero condition defined in clarification Q5.

**Alternatives considered**:
- Pass `relationships.toml` entry count separately: adds coupling between filesystem and graph; `EdgeCount()` is already available on the graph and reflects the correct semantic.
- Change message text instead of suppressing: clarification Q5 resolved this — suppress entirely when zero.

---

## R-007: Graph Cache Invalidation (FR-017)

**Decision**: Call `graphCache.Invalidate(projectRoot)` at the end of `CreateRelationship`, `DeleteRelationship`, and any operation that writes to `relationships.toml`. The `GraphCache.Invalidate()` method already exists and is thread-safe (`sync.RWMutex`).

**Where to call**: In the MCP tool handlers (after use case succeeds), OR in the use cases themselves if the cache is passed as a dependency. Given the cache lives in `internal/mcp/` and use cases must not import mcp, **call from the MCP tool handler** after the use case returns successfully.

**Pattern** (in `create_relationship.go` MCP handler):
```go
result, err := uc.Execute(ctx, req)
if err != nil { return nil, err }
t.graphCache.Invalidate(projectRoot)  // eager invalidation
return result, nil
```

**Inject `GraphCache`**: Pass `*mcp.GraphCache` to relationship tool constructors. This is already the pattern for `graph_tools.go` which accesses the cache via the server.

---

## Summary: All NEEDS CLARIFICATION Resolved

| Research Item | Decision |
|---|---|
| R-001 | `relationships.toml` per system, `[[relationships]]` TOML array, deterministic SHA-256 ID |
| R-002 | Regenerate D2 edges section from TOML on every write; container→container in `system.d2` |
| R-003 | `suggestSlugID` + `notFoundError` helpers in `mcp/tools/helpers.go` |
| R-004 | Inject `DiagramGenerator` into `CreateContainerTool`; existing scaffold path handles the rest |
| R-005 | `create_components` loops sequentially over `ScaffoldEntity`, returns mixed results array |
| R-006 | Skip `checkIsolatedComponents` when `graph.EdgeCount() == 0` |
| R-007 | Call `graphCache.Invalidate(projectRoot)` from MCP tool handler after use case success |
