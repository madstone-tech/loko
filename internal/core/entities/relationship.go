package entities

import (
	"crypto/sha256"
	"fmt"
	"strings"
)

// Relationship represents a directed dependency between two C4 model elements.
// It is persisted in src/<system-id>/relationships.toml as a TOML array-of-tables.
//
// Element paths use slash-separated qualified IDs:
//   - Container: "system-id/container-id"
//   - Component: "system-id/container-id/component-id"
type Relationship struct {
	// ID is a deterministic 8-hex-char SHA-256 hash of source+target+label.
	// Callers must not set this field; it is generated by NewRelationship.
	ID string `toml:"id"                   json:"id"`

	// Source is the slash-separated element path of the originating element.
	Source string `toml:"source"               json:"source"`

	// Target is the slash-separated element path of the receiving element.
	Target string `toml:"target"               json:"target"`

	// Label is a human-readable description of the relationship (e.g., "Enqueue email job").
	Label string `toml:"label"                json:"label"`

	// Type describes the interaction pattern. One of: "sync", "async", "event".
	// Defaults to "sync" when not specified.
	Type string `toml:"type,omitempty"       json:"type,omitempty"`

	// Technology is a free-text description of the technology used (e.g., "AWS SDK SQS").
	Technology string `toml:"technology,omitempty" json:"technology,omitempty"`

	// Direction is one of: "forward", "bidirectional". Defaults to "forward".
	Direction string `toml:"direction,omitempty"  json:"direction,omitempty"`
}

// RelationshipsFile is the top-level TOML structure for relationships.toml.
// It wraps a slice of Relationship entries under the [relationships] table array key.
type RelationshipsFile struct {
	Relationships []Relationship `toml:"relationships" json:"relationships"`
}

// RelationshipOption configures optional fields on a Relationship.
type RelationshipOption func(*Relationship)

// WithRelType sets the relationship interaction type.
// Must be one of: "sync", "async", "event".
func WithRelType(t string) RelationshipOption {
	return func(r *Relationship) {
		r.Type = t
	}
}

// WithRelTechnology sets the free-text technology description.
func WithRelTechnology(tech string) RelationshipOption {
	return func(r *Relationship) {
		r.Technology = tech
	}
}

// WithRelDirection sets the directionality of the relationship.
// Must be one of: "forward", "bidirectional".
func WithRelDirection(dir string) RelationshipOption {
	return func(r *Relationship) {
		r.Direction = dir
	}
}

// validRelTypes is the set of valid relationship Type values.
var validRelTypes = map[string]bool{
	"sync":  true,
	"async": true,
	"event": true,
}

// validDirections is the set of valid Direction values.
var validDirections = map[string]bool{
	"forward":       true,
	"bidirectional": true,
}

// NewRelationship creates a validated Relationship entity.
//
// The ID is generated deterministically from source+target+label using SHA-256;
// callers cannot override it. The constructor applies option defaults before
// validating enum values, so callers need not provide Type or Direction.
//
// Validation rules:
//   - source must be non-empty
//   - target must be non-empty
//   - source must not equal target (no self-references)
//   - label must be non-empty
//   - type (if set) must be "sync", "async", or "event"
//   - direction (if set) must be "forward" or "bidirectional"
func NewRelationship(source, target, label string, opts ...RelationshipOption) (*Relationship, error) {
	r := &Relationship{
		Source: source,
		Target: target,
		Label:  label,
		// Apply defaults for optional enum fields so enum validation below
		// can report a meaningful error for explicitly invalid values.
		Type:      "sync",
		Direction: "forward",
	}

	// Apply caller options (may override defaults).
	for _, opt := range opts {
		opt(r)
	}

	// Validate required fields.
	if strings.TrimSpace(r.Source) == "" {
		return nil, &ValidationError{
			Entity:  "Relationship",
			Field:   "source",
			Message: "source cannot be empty",
			Err:     ErrEmptySource,
		}
	}
	if strings.TrimSpace(r.Target) == "" {
		return nil, &ValidationError{
			Entity:  "Relationship",
			Field:   "target",
			Message: "target cannot be empty",
		}
	}
	if r.Source == r.Target {
		return nil, &ValidationError{
			Entity:  "Relationship",
			Field:   "source",
			Value:   r.Source,
			Message: "source and target must be different (no self-references)",
		}
	}
	if strings.TrimSpace(r.Label) == "" {
		return nil, &ValidationError{
			Entity:  "Relationship",
			Field:   "label",
			Message: "label cannot be empty",
		}
	}

	// Validate enum fields.
	if r.Type != "" && !validRelTypes[r.Type] {
		return nil, &ValidationError{
			Entity:  "Relationship",
			Field:   "type",
			Value:   r.Type,
			Message: fmt.Sprintf("type must be one of: sync, async, event; got %q", r.Type),
		}
	}
	if r.Direction != "" && !validDirections[r.Direction] {
		return nil, &ValidationError{
			Entity:  "Relationship",
			Field:   "direction",
			Value:   r.Direction,
			Message: fmt.Sprintf("direction must be one of: forward, bidirectional; got %q", r.Direction),
		}
	}

	// Generate deterministic ID after all validation passes.
	r.ID = GenerateRelationshipID(r.Source, r.Target, r.Label)

	return r, nil
}

// GenerateRelationshipID returns an 8-hex-character deterministic ID for a relationship.
//
// The ID is derived from SHA-256(source + "->" + target + ":" + label) truncated
// to 8 hex chars (32-bit prefix). The same inputs always produce the same ID,
// enabling idempotent create_relationship calls.
//
// Only stdlib crypto/sha256 is used; no external dependencies.
func GenerateRelationshipID(source, target, label string) string {
	key := source + "->" + target + ":" + label
	sum := sha256.Sum256([]byte(key))
	return fmt.Sprintf("%x", sum[:4]) // 4 bytes → 8 hex chars
}

// RelationshipToD2Edge converts a Relationship to a D2 edge declaration string.
//
// D2 syntax rules applied:
//   - Forward arrow: "->"
//   - Bidirectional arrow: "<->"
//   - Async type: adds style.animated: true
//   - Event type: adds style.stroke-dash: 5
//   - Sync (default): plain quoted label
//
// The function uses only the last path segment of Source/Target as D2 node references
// (i.e., "backend/api-lambda" → "api-lambda") to match the node IDs used in D2 files.
func RelationshipToD2Edge(rel Relationship) string {
	arrow := "->"
	if rel.Direction == "bidirectional" {
		arrow = "<->"
	}

	src := lastPathSegment(rel.Source)
	tgt := lastPathSegment(rel.Target)

	switch rel.Type {
	case "async":
		return fmt.Sprintf("%s %s %s: { label: %q; style.animated: true }\n", src, arrow, tgt, rel.Label)
	case "event":
		return fmt.Sprintf("%s %s %s: { label: %q; style.stroke-dash: 5 }\n", src, arrow, tgt, rel.Label)
	default: // "sync" or empty
		return fmt.Sprintf("%s %s %s: %q\n", src, arrow, tgt, rel.Label)
	}
}

// lastPathSegment returns the last slash-separated segment of a path.
// "backend/api-lambda" → "api-lambda". Returns the full string if no slash found.
func lastPathSegment(path string) string {
	if idx := strings.LastIndex(path, "/"); idx >= 0 {
		return path[idx+1:]
	}
	return path
}
